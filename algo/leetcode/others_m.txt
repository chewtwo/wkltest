Medium - Others

371.Sum of Two Integers
    两整数之和
150.Evaluate Reverse Polish Notation
    逆波兰表达式求值
169.Majority Element
    多数元素
277.Find the Celebrity
    搜寻名人
621.Task Scheduler
    任务调度器

*****************************************************************************************************
#371 Sum of Two Integers
     两整数之和
*****************************************************************************************************
not allowed to use the operator + and -

Example 1:
Input: a = 1, b = 2
Output: 3

Example 2:
Input: a = -2, b = 3
Output: 1

class Solution {
public:
    int getSum(int a, int b) {
       // Iterate till there is no carry  
        while (b != 0)  
        {  
            // carry now contains common  
            //set bits of x and y  
            int carry = a & b;  
    
            // Sum of bits of x and y where at  
            //least one of the bits is not set  
            a = a ^ b;  
    
            // Carry is shifted by one so that adding  
            // it to x gives the required sum  
            b = (carry&0xffffffff) << 1;  
        }  
        return a;   
    }
};

class Solution {
public:
    int getSum(int a, int b) {
       if (b == 0) 
        return a; 
    else
        return getSum( a ^ b, (a & b & 0xffffffff) << 1);
    }
};

*****************************************************************************************************
#150 Evaluate Reverse Polish Notation
     逆波兰表达式求值
*****************************************************************************************************
Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:
Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result 
and there won't be any divide by zero operation.

Example 1:
Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Example 2:
Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6

Example 3:
Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        unordered_map<string, function<int (int, int) > > map = {
            { "+" , [] (int a, int b) { return a + b; } },
            { "-" , [] (int a, int b) { return a - b; } },
            { "*" , [] (int a, int b) { return a * b; } },
            { "/" , [] (int a, int b) { return a / b; } }
        };
        std::stack<int> stack;
        for (string& s : tokens) {
            if (!map.count(s)) {
                stack.push(stoi(s));
            } else {
                int op1 = stack.top();
                stack.pop();
                int op2 = stack.top();
                stack.pop();
                stack.push(map[s](op2, op1));
            }
        }
        return stack.top();
    }
};

*****************************************************************************************************
#169 Majority Element
     多数元素
*****************************************************************************************************
more than ⌊ n/2 ⌋ times

Example 1:
Input: [3,2,3]
Output: 3

Example 2:
Input: [2,2,1,1,1,2,2]
Output: 2

此处假设必有，若非必有，则cand再count一轮

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 0;
        int candidate = nums[0];

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }

        return candidate;
    }
};

*****************************************************************************************************
#277 Find the Celebrity
     搜寻名人
*****************************************************************************************************
“名人” 的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人
派对最多只会有一个 “名人” 参加。若 “名人” 存在，请返回他/她的编号；若 “名人” 不存在，请返回 -1

Example 1:
Input: graph = [
  [1,1,0],
  [0,1,0],
  [1,1,1]
]
Output: 1
Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, 
otherwise graph[i][j] = 0 means person i does not know person j. 
The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.

Example 2:
Input: graph = [
  [1,0,1],
  [1,1,0],
  [0,1,1]
]
Output: -1
Explanation: There is no celebrity.

// Forward declaration of the knows API.
bool knows(int a, int b);

class Solution {
public:
    int findCelebrity(int n) {
        // Initialize two pointers  
        // as two corners 
        int a = 0; 
        int b = n - 1; 
    
        // Keep moving while  
        // the two pointers 
        // don't become same.  
        while (a < b) 
        { 
            if (knows(a, b)) 
                a++; 
            else
                b--; 
        } 
    
        // Check if a is actually 
        // a celebrity or not 
        for (int i = 0; i < n; i++) 
        { 
            // If any person doesn't  
            // know 'a' or 'a' doesn't 
            // know any person, return -1 
            if ( (i != a) && 
                    (knows(a, i) ||  
                    !knows(i, a)) ) 
                return -1; 
        } 
    
        return a;
    }
};

*****************************************************************************************************
#621 Task Scheduler
     任务调度器
*****************************************************************************************************
两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。

Example:
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.

Note:
The number of tasks is in the range [1, 10000].
The integer n is in the range [0, 100].

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        unordered_map<char,int>mp;
        int count = 0;
        for(auto e : tasks)
        {
            mp[e]++;
            count = max(count, mp[e]);
        }
        
        int ans = (count-1)*(n+1);
        for(auto e : mp) if(e.second == count) ans++;
        return max((int)tasks.size(), ans);
    }
};



